package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String  ID;
terminal String  STRING_LITERAL;
terminal String  CHAR_LITERAL;          
terminal Integer DECIMAL_LITERAL;

/* punctuation / keywords / operators (no value) */
terminal INT, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, COLON;
terminal AUTO, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, ENUM, EXTERN, FOR, GOTO, IF, REGISTER, RETURN,
         SHORT, SIGNED, DOUBLE, CONST, STRUCT, SIZEOF, LONG, FLOAT, UNION, VOID, VOLATILE,
         UNSIGNED, STATIC, TYPEDEF, WHILE, CHAR;   /* include anything you actually use */

terminal PLUS, MINUS, TIMES, DIVIDE, MODULUS;
terminal ASSIGN;
terminal EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR;                      /* &&, || */
terminal BITWISEAND, BWISEOR, BWISEXOR, TILDE;
terminal LSHIFT, RSHIFT;
terminal ADDASSIGN, SUBASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN,
         BWISEANDASSIGN, BWISEORASSIGN, BWISEXORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN;
terminal INCREMENT, DECREMENT;
terminal PERIOD, ARROW;
terminal ELIPSES;                      
terminal FUN, VAR;                     

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;


/* Statement-related non-terminals */
non terminal Absyn.Stm statement;          
non terminal Absyn.Stm labeled_statement;
non terminal Absyn.Stm compound_statement;
non terminal Absyn.Stm expression_statement;
non terminal Absyn.Stm selection_statement;
non terminal Absyn.Stm iteration_statement;
non terminal Absyn.Stm jump_statement;
non terminal Absyn.StmList statement_list;  
non terminal Absyn.DecList declaration_list; 
non terminal Absyn.Dec declaration;          
non terminal Absyn.Exp expression_opt;
non terminal Symbol.Symbol name;
non terminal Integer bitfield_list, bitfield_value;
non terminal Integer struct_or_union;
non terminal Absyn.Ty type, type_augments, brackets_list, pointer_list;
non terminal Absyn.ExpList empty_array_type_list, expression_array_type_list;
non terminal Absyn.Exp empty_array_type, expression_array_type;
non terminal Absyn.Exp initialization, initializer;
non terminal Absyn.ExpList initializer_list;
non terminal Absyn.FieldList struct_or_union_declarator, struct_declaration_list;
non terminal Absyn.FieldList parameters, parameter_list;
non terminal Absyn.TypeList type_parameters, parameter_type_list;
non terminal Absyn.EnumeratorList enumerator_list;
non terminal Absyn.Enumerator enumerator;     
non terminal Absyn.Exp          primary_expression, postfix_expression, unary_expression;
non terminal Absyn.Exp          cast_expression, multiplicative_expression, additive_expression;
non terminal Absyn.Exp          shift_expression, relational_expression, equality_expression;
non terminal Absyn.Exp          AND_expression, exclusive_OR_expression, inclusive_OR_expression;
non terminal Absyn.Exp          logical_AND_expression, logical_OR_expression, conditional_expression;
non terminal Absyn.Exp          assignment_expression, expression, constant_expression;
non terminal Absyn.ExpList      argument_expression_list;
non terminal Integer            unary_operator;
non terminal Object             type_name;


start with declaration;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;

primary_expression ::=
      ID:id       
      {: RESULT = new Absyn.VarExp(idleft, new Absyn.SimpleVar(idleft, sym(id))); :}
    | DECIMAL_LITERAL:i       
      {: RESULT = new Absyn.IntExp(ileft, i.intValue()); :}
    | STRING_LITERAL:str    
      {: RESULT = new Absyn.StringExp(strleft, str); :}
    | CHAR_LITERAL:c
      {: RESULT = new Absyn.CharExp(cleft, c.length() > 1 ? c.charAt(1) : c.charAt(0)); :}
    | LPAREN expression:e RPAREN 
      {: RESULT = e; :}
    ;


argument_expression_list ::= 
      assignment_expression:e
      {: RESULT = new Absyn.ExpList(e, null); :}
    | argument_expression_list:list COMMA assignment_expression:e
      {: RESULT = new Absyn.ExpList(e, list); :}
    ;

postfix_expression ::= 
      primary_expression:e 
      {: RESULT = e; :}
    | postfix_expression:arr LBRACK expression:idx RBRACK
      {: RESULT = new Absyn.SubscriptExp(arrleft, arr, idx); :}
    | postfix_expression:func LPAREN argument_expression_list:args RPAREN
      {: RESULT = new Absyn.CallExp(funcleft, func, args); :}
    | postfix_expression:func LPAREN RPAREN
      {: RESULT = new Absyn.CallExp(funcleft, func, null); :}
    | postfix_expression:rec PERIOD ID:field
      {: RESULT = new Absyn.FieldExp(recleft, rec, sym(field), false); :}
    | postfix_expression:rec ARROW ID:field
      {: RESULT = new Absyn.FieldExp(recleft, rec, sym(field), true); :}
    | postfix_expression:e INCREMENT
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.POST_INC, e, null); :}
    | postfix_expression:e DECREMENT
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.POST_DEC, e, null); :}
    ;

unary_operator ::=
      BITWISEAND
      {: RESULT = null; :}
    | TIMES
      {: RESULT = null; :}
    | PLUS
      {: RESULT = null; :}
    | MINUS
      {: RESULT = null; :}
    | TILDE
      {: RESULT = null; :}
    ;

unary_expression ::=
      postfix_expression:e
      {: RESULT = e; :}
    | INCREMENT unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.PRE_INC, e, null); :}
    | DECREMENT unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.PRE_DEC, e, null); :}
    | BITWISEAND cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.ADDRESS, e, null); :}
    | TIMES cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.DEREFERENCE, e, null); :}
    | PLUS cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.UNARY_PLUS, e, null); :}
    | MINUS cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.UNARY_MINUS, e, null); :}
    | TILDE cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.BITWISE_NOT, e, null); :}
    | SIZEOF unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.SIZEOF, e, null); :}
    | SIZEOF LPAREN type_name:t RPAREN
      {: RESULT = new Absyn.OpExp(tleft, Absyn.OpExp.SIZEOF, null, null); :}
    ;

cast_expression ::=
      unary_expression:e
      {: RESULT = e; :}
    | LPAREN type_name:t RPAREN cast_expression:e
      {: RESULT = new Absyn.CastExp(tleft, t, e); :}
    ;

type_name ::=
      VOID
      {: RESULT = Symbol.Symbol.symbol("void"); :}
    | CHAR
      {: RESULT = Symbol.Symbol.symbol("char"); :}
    | SHORT
      {: RESULT = Symbol.Symbol.symbol("short"); :}
    | INT 
      {: RESULT = Symbol.Symbol.symbol("int"); :}
    | LONG
      {: RESULT = Symbol.Symbol.symbol("long"); :}
    | FLOAT
      {: RESULT = Symbol.Symbol.symbol("float"); :}
    | DOUBLE
      {: RESULT = Symbol.Symbol.symbol("double"); :}
    | ENUM ID:id
      {: RESULT = Symbol.Symbol.symbol("enum " + id); :}
    | ID:id
      {: RESULT = Symbol.Symbol.symbol(id); :}
    ;

multiplicative_expression ::= 
      cast_expression:e
      {: RESULT = e; :}
    | multiplicative_expression:e1 TIMES cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.TIMES, e1, e2); :}
    | multiplicative_expression:e1 DIVIDE cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.DIVIDE, e1, e2); :}
    | multiplicative_expression:e1 MODULUS cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.MOD, e1, e2); :}
    ;

additive_expression ::=
      multiplicative_expression:e
      {: RESULT = e; :}
    | additive_expression:e1 PLUS multiplicative_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.PLUS, e1, e2); :}
    | additive_expression:e1 MINUS multiplicative_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.MINUS, e1, e2); :}
    ;

shift_expression ::=
      additive_expression:e
      {: RESULT = e; :}
    | shift_expression:e1 LSHIFT additive_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LSHIFT, e1, e2); :}
    | shift_expression:e1 RSHIFT additive_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.RSHIFT, e1, e2); :}
    ;

relational_expression ::=
      shift_expression:e
      {: RESULT = e; :}
    | relational_expression:e1 LT shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LT, e1, e2); :}
    | relational_expression:e1 GT shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.GT, e1, e2); :}
    | relational_expression:e1 LE shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LE, e1, e2); :}
    | relational_expression:e1 GE shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.GE, e1, e2); :}
    ;

equality_expression ::=
      relational_expression:e
      {: RESULT = e; :}
    | equality_expression:e1 EQ relational_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.EQ, e1, e2); :}
    | equality_expression:e1 NEQ relational_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.NE, e1, e2); :}
    ;

AND_expression ::=
      equality_expression:e
      {: RESULT = e; :}
    | AND_expression:e1 BITWISEAND equality_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_AND, e1, e2); :}
    ;

exclusive_OR_expression ::=
      AND_expression:e
      {: RESULT = e; :}
    | exclusive_OR_expression:e1 BWISEXOR AND_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_XOR, e1, e2); :}
    ;

inclusive_OR_expression ::=
      exclusive_OR_expression:e
      {: RESULT = e; :}
    | inclusive_OR_expression:e1 BWISEOR exclusive_OR_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_OR, e1, e2); :}
    ;

logical_AND_expression ::=
      inclusive_OR_expression:e
      {: RESULT = e; :}
    | logical_AND_expression:e1 AND inclusive_OR_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.AND, e1, e2); :}
    ;

logical_OR_expression ::=
      logical_AND_expression:e
      {: RESULT = e; :}
    | logical_OR_expression:e1 OR logical_AND_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.OR, e1, e2); :}
    ;

conditional_expression ::=
      logical_OR_expression:e
      {: RESULT = e; :}
    ;

assignment_expression ::=
      conditional_expression:e
      {: RESULT = e; :}
    | unary_expression:target ASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.ASSIGN, target, value); :}
    | unary_expression:target MULASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.TIMES_ASSIGN, target, value); :}
    | unary_expression:target DIVASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.DIVIDE_ASSIGN, target, value); :}
    | unary_expression:target MODASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.MOD_ASSIGN, target, value); :}
    | unary_expression:target ADDASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.PLUS_ASSIGN, target, value); :}
    | unary_expression:target SUBASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.MINUS_ASSIGN, target, value); :}
    | unary_expression:target LSHIFTASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.LSHIFT_ASSIGN, target, value); :}
    | unary_expression:target RSHIFTASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.RSHIFT_ASSIGN, target, value); :}
    | unary_expression:target BWISEANDASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.AND_ASSIGN, target, value); :}
    | unary_expression:target BWISEXORASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.XOR_ASSIGN, target, value); :}
    | unary_expression:target BWISEORASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.OR_ASSIGN, target, value); :}
    ;

expression ::=
      assignment_expression:e
      {: RESULT = e; :}
    | expression:e1 COMMA assignment_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.COMMA, e1, e2); :}
    ;

constant_expression ::=
      conditional_expression:e
      {: RESULT = e; :}
    ;

/* Statement grammar */
statement ::=
      labeled_statement:s
      {: RESULT = s; :}
    | compound_statement:s
      {: RESULT = s; :}
    | expression_statement:s
      {: RESULT = s; :}
    | selection_statement:s
      {: RESULT = s; :}
    | iteration_statement:s
      {: RESULT = s; :}
    | jump_statement:s
      {: RESULT = s; :}
    ;

/* Labeled statements */
labeled_statement ::=
      ID:label COLON statement:s
      {: RESULT = new Absyn.LabeledStm(labelleft, sym(label), s); :}
    | CASE constant_expression:e COLON statement:s
      {: RESULT = new Absyn.CaseStm(eleft, e, s); :}
    | DEFAULT COLON statement:s
      {: RESULT = new Absyn.DefaultStm(sleft, s); :}
    ;

/* Compound statement or block */
compound_statement ::=
      LBRACE:lb RBRACE
      {: RESULT = new Absyn.CompoundStm(lbleft, null, null); :}
    | LBRACE:lb statement_list:stms RBRACE
      {: RESULT = new Absyn.CompoundStm(lbleft, null, stms); :}
    | LBRACE:lb declaration_list:decs RBRACE
      {: RESULT = new Absyn.CompoundStm(lbleft, decs, null); :}
    | LBRACE:lb declaration_list:decs statement_list:stms RBRACE
      {: RESULT = new Absyn.CompoundStm(lbleft, decs, stms); :}
    ;

declaration_list ::=
      declaration:d
      {: RESULT = new Absyn.DecList(d, null); :}
    | declaration_list:dl declaration:d
      {: RESULT = new Absyn.DecList(d, dl); :}
    ;

/* Declaration rules */
declaration ::=
      VAR:v bitfield_list:bf type:t name:n initialization:i SEMICOLON
      {: RESULT = new Absyn.VarDec(vleft, bf, t, n, i); :}
    | FUN:f bitfield_list:bf type:t name:n parameters:p compound_statement:body
      {: RESULT = new Absyn.FunctionDec(fleft, bf, t, n, p, false, body); :}
    | FUN:f bitfield_list:bf type:t name:n type_parameters:p SEMICOLON
      {: RESULT = new Absyn.FunctionDec(fleft, bf, t, n, null, false, null); :}
    | TYPEDEF:td type:t name:n SEMICOLON
      {: RESULT = new Absyn.TypedefDec(tdleft, t, n); :}
    | bitfield_list:bf struct_or_union:su name:n struct_or_union_declarator:fields SEMICOLON
      {: if (su == 1) { RESULT = new Absyn.StructDec(0, bf, n, fields); } else { RESULT = new Absyn.UnionDec(0, bf, n, fields); } :}
    | ENUM:e ID:n LBRACE enumerator_list:enums RBRACE
      {: RESULT = new Absyn.EnumDec(eleft, 0, sym(n), enums); :}
    ;

/* Name */
name ::=
      ID:n
      {: RESULT = sym(n); :}
    ;

/* Bitfield list */
bitfield_list ::=
      /* empty */
      {: RESULT = 0; :}
    | bitfield_value:bf bitfield_list:rest
      {: RESULT = bf | rest; :}
    ;

bitfield_value ::=
      CONST
      {: RESULT = Absyn.VarDec.CONST; :}
    | VOLATILE
      {: RESULT = Absyn.VarDec.VOLATILE; :}
    | EXTERN
      {: RESULT = Absyn.VarDec.EXTERN; :}
    | STATIC
      {: RESULT = Absyn.VarDec.STATIC; :}
    | AUTO
      {: RESULT = Absyn.VarDec.AUTO; :}
    | REGISTER
      {: RESULT = Absyn.VarDec.REGISTER; :}
    ;

/* Array types */
empty_array_type_list ::=
      empty_array_type:e
      {: RESULT = new Absyn.ExpList(e, null); :}
    | empty_array_type_list:list empty_array_type:e
      {: RESULT = new Absyn.ExpList(e, list); :}
    ;

empty_array_type ::=
      LBRACK RBRACK
      {: RESULT = null; :}
    ;

expression_array_type_list ::=
      expression_array_type:e
      {: RESULT = new Absyn.ExpList(e, null); :}
    | expression_array_type_list:list expression_array_type:e
      {: RESULT = new Absyn.ExpList(e, list); :}
    ;

expression_array_type ::=
      LBRACK constant_expression:e RBRACK
      {: RESULT = e; :}
    ;

/* Type specifications */
type ::=
      type_name:tn type_augments:aug
      {: RESULT = aug; :}
    | type_name:tn
      {: Symbol.Symbol typeSym = (tn instanceof Symbol.Symbol) ? (Symbol.Symbol)tn : Symbol.Symbol.symbol(tn.toString()); RESULT = new Absyn.NameTy(0, typeSym, 0, null); :}
    ;

type_augments ::=
      pointer_list:pl
      {: RESULT = pl; :}
    | brackets_list:bl
      {: RESULT = bl; :}
    | pointer_list:pl brackets_list:bl
      {: RESULT = pl; :}
    ;

brackets_list ::=
      empty_array_type_list:list
      {: RESULT = new Absyn.NameTy(0, Symbol.Symbol.symbol("array"), 0, list); :}
    | expression_array_type_list:list
      {: RESULT = new Absyn.NameTy(0, Symbol.Symbol.symbol("array"), 0, list); :}
    ;

pointer_list ::=
      TIMES
      {: RESULT = new Absyn.NameTy(0, Symbol.Symbol.symbol("pointer"), 1, null); :}
    | pointer_list:pl TIMES
      {: RESULT = new Absyn.NameTy(0, Symbol.Symbol.symbol("pointer"), ((Absyn.NameTy)pl).pointerDepth + 1, null); :}
    ;

/* Initialization */
initialization ::=
      /* empty */
      {: RESULT = null; :}
    | ASSIGN initializer:initval
      {: RESULT = initval; :}
    ;

/* Struct/Union */
struct_or_union_declarator ::=
      LBRACE struct_declaration_list:fields RBRACE
      {: RESULT = fields; :}
    ;

enumerator_list ::=
      enumerator:e
      {: RESULT = new Absyn.EnumeratorList(e, null); :}
    | enumerator_list:list COMMA enumerator:e
      {: RESULT = new Absyn.EnumeratorList(e, list); :}
    ;

enumerator ::=
      ID:n
      {: RESULT = new Absyn.Enumerator(sym(n), null); :}
    | ID:n ASSIGN constant_expression:e
      {: RESULT = new Absyn.Enumerator(sym(n), e); :}
    ;

struct_declaration_list ::=
      type:t name:n SEMICOLON
      {: RESULT = new Absyn.FieldList(t, n, null); :}
    | struct_declaration_list:list type:t name:n SEMICOLON
      {: RESULT = new Absyn.FieldList(t, n, list); :}
    ;

struct_or_union ::=
      STRUCT
      {: RESULT = 1; :}
    | UNION
      {: RESULT = 2; :}
    ;

/* Parameters */
type_parameters ::=
      LPAREN parameter_type_list:params RPAREN
      {: RESULT = params; :}
    | LPAREN parameter_type_list:params COMMA ELIPSES RPAREN
      {: RESULT = params; :}
    | LPAREN RPAREN
      {: RESULT = null; :}
    ;

parameters ::=
      LPAREN parameter_list:params RPAREN
      {: RESULT = params; :}
    | LPAREN parameter_list:params COMMA ELIPSES RPAREN
      {: RESULT = params; :}
    | LPAREN RPAREN
      {: RESULT = null; :}
    ;

parameter_list ::=
      type:t name:n
      {: RESULT = new Absyn.FieldList(t, n, null); :}
    | parameter_list:list COMMA type:t name:n
      {: RESULT = new Absyn.FieldList(t, n, list); :}
    ;

parameter_type_list ::=
      type:t
      {: RESULT = new Absyn.TypeList(t, null); :}
    | parameter_type_list:list COMMA type:t
      {: RESULT = new Absyn.TypeList(t, list); :}
    ;

/* Initializers */
initializer_list ::=
      initializer:initval
      {: RESULT = new Absyn.ExpList(initval, null); :}
    | initializer_list:list COMMA initializer:initval
      {: RESULT = new Absyn.ExpList(initval, list); :}
    ;

initializer ::=
      assignment_expression:e
      {: RESULT = e; :}
    | LBRACE initializer_list:list RBRACE
      {: RESULT = new Absyn.SeqExp(0, list); :}
    ;

statement_list ::=
      statement:s
      {: RESULT = new Absyn.StmList(s, null); :}
    | statement_list:sl statement:s
      {: RESULT = new Absyn.StmList(s, sl); :}
    ;

/* Expression and null statements */
expression_statement ::=
      SEMICOLON:s
      {: RESULT = new Absyn.ExpressionStm(sleft, null); :}
    | expression:e SEMICOLON
      {: RESULT = new Absyn.ExpressionStm(eleft, e); :}
    ;

/* Selection statements */
selection_statement ::=
      IF:i LPAREN expression:test RPAREN statement:then
      {: RESULT = new Absyn.IfStm(ileft, test, then, null); :}
    | IF:i LPAREN expression:test RPAREN statement:then ELSE statement:elsepart
      {: RESULT = new Absyn.IfStm(ileft, test, then, elsepart); :}
    ;

/* switch statement not implemented per requirements on moodle project guidnlines */

/* Iteration statements */
iteration_statement ::=
      WHILE:w LPAREN expression:test RPAREN statement:body
      {: RESULT = new Absyn.WhileStm(wleft, test, body); :}
    | DO:d statement:body WHILE LPAREN expression:test RPAREN SEMICOLON
      {: RESULT = new Absyn.DoWhileStm(dleft, body, test); :}
    | FOR:f LPAREN expression_opt:i SEMICOLON expression_opt:t SEMICOLON expression_opt:inc RPAREN statement:body
      {: RESULT = new Absyn.ForStm(fleft, i, t, inc, body); :}
    ;

expression_opt ::=
      /* empty */
      {: RESULT = null; :}
    | expression:e
      {: RESULT = e; :}
    ;

/* Jump statements */
jump_statement ::=
      GOTO:g ID:label SEMICOLON
      {: RESULT = new Absyn.GotoStm(gleft, sym(label)); :}
    | CONTINUE:c SEMICOLON
      {: RESULT = new Absyn.ContinueStm(cleft); :}
    | BREAK:b SEMICOLON
      {: RESULT = new Absyn.BreakStm(bleft); :}
    | RETURN:r SEMICOLON
      {: RESULT = new Absyn.ReturnStm(rleft, null); :}
    | RETURN:r expression:e SEMICOLON
      {: RESULT = new Absyn.ReturnStm(rleft, e); :}
    ;

