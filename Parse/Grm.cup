package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String  ID;
terminal String  STRING_LITERAL;
terminal String  CHAR_LITERAL;          
terminal Integer DECIMAL_LITERAL;

/* punctuation / keywords / operators (no value) */
terminal INT, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, COLON;
terminal AUTO, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, ENUM, EXTERN, FOR, GOTO, IF, REGISTER, RETURN,
         SHORT, SIGNED, DOUBLE, CONST, STRUCT, SIZEOF, LONG, FLOAT, UNION, VOID, VOLATILE,
         UNSIGNED, STATIC, TYPEDEF, WHILE, CHAR;   /* include anything you actually use */

terminal PLUS, MINUS, TIMES, DIVIDE, MODULUS;
terminal ASSIGN;
terminal EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR;                      /* &&, || */
terminal BITWISEAND, BWISEOR, BWISEXOR, TILDE;
terminal LSHIFT, RSHIFT;
terminal ADDASSIGN, SUBASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN,
         BWISEANDASSIGN, BWISEORASSIGN, BWISEXORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN;
terminal INCREMENT, DECREMENT;
terminal PERIOD, ARROW;
terminal ELIPSES;                      
terminal FUN, VAR;                     

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;


/* Statement-related non-terminals */
non terminal Absyn.Exp statement;          
non terminal Absyn.Exp labeled_statement;
non terminal Absyn.Exp compound_statement;
non terminal Absyn.Exp expression_statement;
non terminal Absyn.Exp selection_statement;
non terminal Absyn.Exp iteration_statement;
non terminal Absyn.Exp jump_statement;
non terminal Absyn.ExpList statement_list;  
non terminal Absyn.DecList declaration_list; 
non terminal Absyn.Dec declaration;          
non terminal Absyn.Exp expression_opt;     
non terminal Absyn.Exp          primary_expression, postfix_expression, unary_expression;
non terminal Absyn.Exp          cast_expression, multiplicative_expression, additive_expression;
non terminal Absyn.Exp          shift_expression, relational_expression, equality_expression;
non terminal Absyn.Exp          AND_expression, exclusive_OR_expression, inclusive_OR_expression;
non terminal Absyn.Exp          logical_AND_expression, logical_OR_expression, conditional_expression;
non terminal Absyn.Exp          assignment_expression, expression, constant_expression;
non terminal Absyn.ExpList      argument_expression_list;
non terminal Integer            unary_operator;
non terminal Object             type_name;


start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	| expression:e
	  {: RESULT = e; :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;

primary_expression ::=
      ID:id       
      {: RESULT = new Absyn.VarExp(idleft, new Absyn.SimpleVar(idleft, sym(id))); :}
    | DECIMAL_LITERAL:i       
      {: RESULT = new Absyn.IntExp(ileft, i.intValue()); :}
    | STRING_LITERAL:str    
      {: RESULT = new Absyn.StringExp(strleft, str); :}
    | CHAR_LITERAL:c
      {: RESULT = new Absyn.CharExp(cleft, c.length() > 1 ? c.charAt(1) : c.charAt(0)); :}
    | LPAREN expression:e RPAREN 
      {: RESULT = e; :}
    ;


argument_expression_list ::= 
      assignment_expression:e
      {: RESULT = new Absyn.ExpList(e, null); :}
    | argument_expression_list:list COMMA assignment_expression:e
      {: RESULT = new Absyn.ExpList(e, list); :}
    ;

postfix_expression ::= 
      primary_expression:e 
      {: RESULT = e; :}
    | postfix_expression:arr LBRACK expression:idx RBRACK
      {: RESULT = new Absyn.SubscriptExp(arrleft, arr, idx); :}
    | postfix_expression:func LPAREN argument_expression_list:args RPAREN
      {: RESULT = new Absyn.CallExp(funcleft, func, args); :}
    | postfix_expression:func LPAREN RPAREN
      {: RESULT = new Absyn.CallExp(funcleft, func, null); :}
    | postfix_expression:rec PERIOD ID:field
      {: RESULT = new Absyn.FieldExp(recleft, rec, sym(field), false); :}
    | postfix_expression:rec ARROW ID:field
      {: RESULT = new Absyn.FieldExp(recleft, rec, sym(field), true); :}
    | postfix_expression:e INCREMENT
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.POST_INC, e, null); :}
    | postfix_expression:e DECREMENT
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.POST_DEC, e, null); :}
    ;

unary_operator ::=
      BITWISEAND
      {: RESULT = null; :}
    | TIMES
      {: RESULT = null; :}
    | PLUS
      {: RESULT = null; :}
    | MINUS
      {: RESULT = null; :}
    | TILDE
      {: RESULT = null; :}
    ;

unary_expression ::=
      postfix_expression:e
      {: RESULT = e; :}
    | INCREMENT unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.PRE_INC, e, null); :}
    | DECREMENT unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.PRE_DEC, e, null); :}
    | BITWISEAND cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.ADDRESS, e, null); :}
    | TIMES cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.DEREFERENCE, e, null); :}
    | PLUS cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.UNARY_PLUS, e, null); :}
    | MINUS cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.UNARY_MINUS, e, null); :}
    | TILDE cast_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.BITWISE_NOT, e, null); :}
    | SIZEOF unary_expression:e
      {: RESULT = new Absyn.OpExp(eleft, Absyn.OpExp.SIZEOF, e, null); :}
    | SIZEOF LPAREN type_name:t RPAREN
      {: RESULT = new Absyn.OpExp(tleft, Absyn.OpExp.SIZEOF, null, null); :}
    ;

cast_expression ::=
      unary_expression:e
      {: RESULT = e; :}
    | LPAREN type_name:t RPAREN cast_expression:e
      {: RESULT = new Absyn.CastExp(tleft, t, e); :}
    ;

type_name ::=
      VOID
      {: RESULT = null; :}
    | CHAR
      {: RESULT = null; :}
    | SHORT
      {: RESULT = null; :}
    | INT 
      {: RESULT = null; :}
    | LONG
      {: RESULT = null; :}
    | FLOAT
      {: RESULT = null; :}
    | DOUBLE
      {: RESULT = null; :}
    | ENUM ID
      {: RESULT = null; :}
    | ID
      {: RESULT = null; :}
    ;

multiplicative_expression ::= 
      cast_expression:e
      {: RESULT = e; :}
    | multiplicative_expression:e1 TIMES cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.TIMES, e1, e2); :}
    | multiplicative_expression:e1 DIVIDE cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.DIVIDE, e1, e2); :}
    | multiplicative_expression:e1 MODULUS cast_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.MOD, e1, e2); :}
    ;

additive_expression ::=
      multiplicative_expression:e
      {: RESULT = e; :}
    | additive_expression:e1 PLUS multiplicative_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.PLUS, e1, e2); :}
    | additive_expression:e1 MINUS multiplicative_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.MINUS, e1, e2); :}
    ;

shift_expression ::=
      additive_expression:e
      {: RESULT = e; :}
    | shift_expression:e1 LSHIFT additive_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LSHIFT, e1, e2); :}
    | shift_expression:e1 RSHIFT additive_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.RSHIFT, e1, e2); :}
    ;

relational_expression ::=
      shift_expression:e
      {: RESULT = e; :}
    | relational_expression:e1 LT shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LT, e1, e2); :}
    | relational_expression:e1 GT shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.GT, e1, e2); :}
    | relational_expression:e1 LE shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.LE, e1, e2); :}
    | relational_expression:e1 GE shift_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.GE, e1, e2); :}
    ;

equality_expression ::=
      relational_expression:e
      {: RESULT = e; :}
    | equality_expression:e1 EQ relational_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.EQ, e1, e2); :}
    | equality_expression:e1 NEQ relational_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.NE, e1, e2); :}
    ;

AND_expression ::=
      equality_expression:e
      {: RESULT = e; :}
    | AND_expression:e1 BITWISEAND equality_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_AND, e1, e2); :}
    ;

exclusive_OR_expression ::=
      AND_expression:e
      {: RESULT = e; :}
    | exclusive_OR_expression:e1 BWISEXOR AND_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_XOR, e1, e2); :}
    ;

inclusive_OR_expression ::=
      exclusive_OR_expression:e
      {: RESULT = e; :}
    | inclusive_OR_expression:e1 BWISEOR exclusive_OR_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.BITWISE_OR, e1, e2); :}
    ;

logical_AND_expression ::=
      inclusive_OR_expression:e
      {: RESULT = e; :}
    | logical_AND_expression:e1 AND inclusive_OR_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.AND, e1, e2); :}
    ;

logical_OR_expression ::=
      logical_AND_expression:e
      {: RESULT = e; :}
    | logical_OR_expression:e1 OR logical_AND_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.OR, e1, e2); :}
    ;

conditional_expression ::=
      logical_OR_expression:e
      {: RESULT = e; :}
    ;

assignment_expression ::=
      conditional_expression:e
      {: RESULT = e; :}
    | unary_expression:target ASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.ASSIGN, target, value); :}
    | unary_expression:target MULASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.TIMES_ASSIGN, target, value); :}
    | unary_expression:target DIVASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.DIVIDE_ASSIGN, target, value); :}
    | unary_expression:target MODASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.MOD_ASSIGN, target, value); :}
    | unary_expression:target ADDASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.PLUS_ASSIGN, target, value); :}
    | unary_expression:target SUBASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.MINUS_ASSIGN, target, value); :}
    | unary_expression:target LSHIFTASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.LSHIFT_ASSIGN, target, value); :}
    | unary_expression:target RSHIFTASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.RSHIFT_ASSIGN, target, value); :}
    | unary_expression:target BWISEANDASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.AND_ASSIGN, target, value); :}
    | unary_expression:target BWISEXORASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.XOR_ASSIGN, target, value); :}
    | unary_expression:target BWISEORASSIGN assignment_expression:value
      {: RESULT = new Absyn.AssignExp(targetleft, Absyn.AssignExp.OR_ASSIGN, target, value); :}
    ;

expression ::=
      assignment_expression:e
      {: RESULT = e; :}
    | expression:e1 COMMA assignment_expression:e2
      {: RESULT = new Absyn.OpExp(e1left, Absyn.OpExp.COMMA, e1, e2); :}
    ;

constant_expression ::=
      conditional_expression:e
      {: RESULT = e; :}
    ;

/* Statement grammar */
statement ::=
      labeled_statement
      {: RESULT = null; :}
    | compound_statement
      {: RESULT = null; :}
    | expression_statement
      {: RESULT = null; :}
    | selection_statement
      {: RESULT = null; :}
    | iteration_statement
      {: RESULT = null; :}
    | jump_statement
      {: RESULT = null; :}
    ;

/* Labeled statements */
labeled_statement ::=
      ID COLON statement
      {: RESULT = null; :}
    | CASE constant_expression COLON statement
      {: RESULT = null; :}
    | DEFAULT COLON statement
      {: RESULT = null; :}
    ;

/* Compound statement or block */
compound_statement ::=
      LBRACE RBRACE
      {: RESULT = null; :}
    | LBRACE statement_list RBRACE
      {: RESULT = null; :}
    | LBRACE declaration_list RBRACE
      {: RESULT = null; :}
    | LBRACE declaration_list statement_list RBRACE
      {: RESULT = null; :}
    ;

declaration_list ::=
      declaration
      {: RESULT = null; :}
    | declaration_list declaration
      {: RESULT = null; :}
    ;

statement_list ::=
      statement
      {: RESULT = null; :}
    | statement_list statement
      {: RESULT = null; :}
    ;

/* Expression and null statements */
expression_statement ::=
      SEMICOLON
      {: RESULT = null; :}
    | expression SEMICOLON
      {: RESULT = null; :}
    ;

/* Selection statements */
selection_statement ::=
      IF LPAREN expression RPAREN statement
      {: RESULT = null; :}
    | IF LPAREN expression RPAREN statement ELSE statement
      {: RESULT = null; :}
    ;

/* switch statement not implemented per requirements on moodle project guidnlines */

/* Iteration statements */
iteration_statement ::=
      WHILE LPAREN expression RPAREN statement
      {: RESULT = null; :}
    | DO statement WHILE LPAREN expression RPAREN SEMICOLON
      {: RESULT = null; :}
    | FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
      {: RESULT = null; :}
    ;

expression_opt ::=
      /* empty */
      {: RESULT = null; :}
    | expression
      {: RESULT = null; :}
    ;

/* Jump statements */
jump_statement ::=
      GOTO ID SEMICOLON
      {: RESULT = null; :}
    | CONTINUE SEMICOLON
      {: RESULT = null; :}
    | BREAK SEMICOLON
      {: RESULT = null; :}
    | RETURN SEMICOLON
      {: RESULT = null; :}
    | RETURN expression SEMICOLON
      {: RESULT = null; :}
    ;