package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String  ID;
terminal String  STRING_LITERAL;
terminal String  CHAR_LITERAL;          /* you can switch to Character if you normalize in lexer */
terminal Integer DECIMAL_LITERAL;

/* punctuation / keywords / operators (no value) */
terminal EOF;
terminal INT, SEMICOLON, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, COMMA, COLON;
terminal AUTO, BREAK, CASE, CONTINUE, DEFAULT, DO, ELSE, ENUM, EXTERN, FOR, GOTO, IF, REGISTER, RETURN,
         SHORT, SIGNED, DOUBLE, CONST, STRUCT, SIZEOF, LONG, FLOAT, UNION, VOID, VOLATILE,
         UNSIGNED, STATIC, TYPEDEF, WHILE, CHAR;   /* include anything you actually use */

terminal PLUS, MINUS, TIMES, DIVIDE, MODULUS;
terminal ASSIGN;
terminal EQ, NEQ, LT, LE, GT, GE;
terminal AND, OR;                      /* &&, || */
terminal BITWISEAND, BWISEOR, BWISEXOR, TILDE;
terminal LSHIFT, RSHIFT;
terminal ADDASSIGN, SUBASSIGN, MULASSIGN, DIVASSIGN, MODASSIGN,
         BWISEANDASSIGN, BWISEORASSIGN, BWISEXORASSIGN, LSHIFTASSIGN, RSHIFTASSIGN;
terminal INCREMENT, DECREMENT;
terminal PERIOD, ARROW;
terminal ELIPSES;                      /* note: your sym spells it ELIPSES */
terminal FUN, VAR;                     

non terminal Absyn.Exp          Exp;
non terminal Absyn.Var          Var;

/* Statement-related non-terminals */
non terminal Absyn.Exp statement;          
non terminal Absyn.Exp labeled_statement;
non terminal Absyn.Exp compound_statement;
non terminal Absyn.Exp expression_statement;
non terminal Absyn.Exp selection_statement;
non terminal Absyn.Exp iteration_statement;
non terminal Absyn.Exp jump_statement;
non terminal Absyn.ExpList statement_list;  
non terminal Absyn.DecList declaration_list; 
non terminal Absyn.Dec declaration;          
non terminal Absyn.Exp expression_opt;     

start with Exp;

Exp ::= error:e
	  {: RESULT = new Absyn.SeqExp(eleft, null); :}
	| Var:v
	  {: RESULT = new Absyn.VarExp(vleft, v); :}
	;

Var ::=   ID:n
	  {: RESULT = new Absyn.SimpleVar(nleft, sym(n)); :}
	;

primary_expression ::=
      ID:id       
      {: RESULT = $1; :}
    | INT:int       
      {: RESULT = $1; :}
    | STRING_LITERAL:str    
      {: RESULT = $1; :}
    | CHAR_LITERAL
      {: RESULT = $1; :}
    | LPAREN Exp:e RPAREN 
      {: RESULT = $e; :}
    ;

argument_expression ::=
\\SYNTAX NOT IN MANUAL

argument_expression_list ::=
      argument_expression
      {: RESULT = $1; :}
    | argument_expression COMMA assignment_expression
      {: RESULT = $1; :}

postfix_expression ::= 
      primary_expression 
      {: RESULT = $1; :}
    | postfix_expression LBRACK Exp:e RBRACK
      {: RESULT = $1; :}
    | postfix_expression LPAREN argument_expression_list RPAREN
      {: RESULT = $1; :}
    | postfix_expression DOT ID
      {: RESULT = $1; :}
    | postfix_expression ARROW ID
      {: RESULT = $1; :}
    | postfix_expression INCREMENT
      {: RESULT = $1; :}
    | postfix_expression DECREMENT
      {: RESULT = $1; :}
    |
unary_operator ::=
      BITWISEAND
      {: RESULT = $1; :}
    | TIMES
      {: RESULT = $1; :}
    | PLUS
      {: RESULT = $1; :}
    | MINUS
      {: RESULT = $1; :}
    | TILDE
      {: RESULT = $1; :}
    
unary_expression ::=
      postfix_expression
      {: RESULT = $1; :}
    | INCREMENT unary_expression
      {: RESULT = $1; :}
    | DECREMENT unary_expression
      {: RESULT = $1; :}
    | unary_operator cast_expression
      {: RESULT = $1; :}
    | SIZEOF unary_expression
      {: RESULT = $1; :}
    | SIZEOF LPAREN type_name RPAREN
      {: RESULT = $1; :}
    
cast_expression ::=
      unary_expression
      {: RESULT = $1; :}
    | LPAREN type_name RPAREN cast_expression
      {: RESULT = $1; :}

type_name ::=
\\SYNTAX NOT IN MANUAL

multiplicative_expression ::= 
      cast_expression
      {: RESULT = $1; :}
    | multiplicative_expression TIMES cast_expression
      {: RESULT = $1; :}
    | multiplicative_expression DIVIDE cast_expression
      {: RESULT = $1; :}
    | multiplicative_expression MODULUS cast_expression
      {: RESULT = $1; :}

additive_expression ::=
      multiplicative_expression
      {: RESULT = $1; :}
    | additive_expression PLUS multiplicative_expression
      {: RESULT = $1; :}
    | additive_expression MINUS multiplicative_expression
      {: RESULT = $1; :}

shift_expression ::=
      additive_expression
      {: RESULT = $1; :}
    | shift_expression LSHIFT additive_expression
      {: RESULT = $1; :}
    | shift_expression RSHIFT additive_expression
      {: RESULT = $1; :}

relational_expression ::=
      shift_expression
      {: RESULT = $1; :}
    | relational_expression LT shift_expression
      {: RESULT = $1; :}
    | relational_expression GT shift_expression
      {: RESULT = $1; :}
    | relational_expression LE shift_expression
      {: RESULT = $1; :}
    | relational_expression GE shift_expression
      {: RESULT = $1; :}

equality_expression ::=
      relational_expression
      {: RESULT = $1; :}
    | equality_expression EQ relational_expression
      {: RESULT = $1; :}
    | equality_expression NEQ relational_expression
      {: RESULT = $1; :}

AND_expression ::=
      equality_expression
      {: RESULT = $1; :}
    | AND_expression BITWISEAND equality_expression
      {: RESULT = $1; :}

exclusive_OR_expression ::=
      AND_expression
      {: RESULT = $1; :}
    | exclusive_OR_expression BWISEXOR AND_expression
      {: RESULT = $1; :}

inclusive_OR_expression ::=
      exclusive_OR_expression
      {: RESULT = $1; :}
    | inclusive_OR_expression BWISEOR exclusive_OR_expression
      {: RESULT = $1; :}
    

logical_AND_expression ::=
      inclusive_OR_expression
      {: RESULT = $1; :}
    | logical_AND_expression AND inclusive_OR_expression
      {: RESULT = $1; :}

logical_OR_expression ::=
      logical_AND_expression
      {: RESULT = $1; :}
    | logical_OR_expression OR logical_AND_expression
      {: RESULT = $1; :}

conditional_expression ::=
      logical_OR_expression
      {: RESULT = $1; :}
    | logical_OR_expression ? expression COLON conditional_expression -> told us not to do question mark ask brandon about this
      {: RESULT = $1; :}

assignment_expression ::=
      conditional_expression
      {: RESULT = $1; :}
    | unary_expression assignment_operator assignment_expression
      {: RESULT = $1; :}

assignment_operator ::=
      ASSIGN
      {: RESULT = $1; :}
    | MULASSIGN
      {: RESULT = $1; :}
    | DIVASSIGN
      {: RESULT = $1; :}
    | MODASSIGN
      {: RESULT = $1; :}
    | ADDASSIGN
      {: RESULT = $1; :}
    | SUBASSIGN
      {: RESULT = $1; :}
    | LSHIFTASSIGN
      {: RESULT = $1; :}
    | RSHIFTASSIGN
      {: RESULT = $1; :}
    | BWISEANDASSIGN
      {: RESULT = $1; :}
    | BWISEXORASSIGN
      {: RESULT = $1; :}
    | BWISEORASSIGN
      {: RESULT = $1; :}

expression ::=
      assignment_expression
      {: RESULT = $1; :}
    | expression COMMA assignment_expression
      {: RESULT = $1; :}

constant_expression ::=
      conditional_expression
      {: RESULT = $1; :}

/* Statement grammar */
statement ::=
      labeled_statement
      {: RESULT = $1; :}
    | compound_statement
      {: RESULT = $1; :}
    | expression_statement
      {: RESULT = $1; :}
    | selection_statement
      {: RESULT = $1; :}
    | iteration_statement
      {: RESULT = $1; :}
    | jump_statement
      {: RESULT = $1; :}
    ;

/* Labeled statements */
labeled_statement ::=
      ID COLON statement
      {: RESULT = $1; :}
    | CASE constant_expression COLON statement
      {: RESULT = $1; :}
    | DEFAULT COLON statement
      {: RESULT = $1; :}
    ;

/* Compound statement or block */
compound_statement ::=
      LBRACE RBRACE
      {: RESULT = $1; :}
    | LBRACE statement_list RBRACE
      {: RESULT = $1; :}
    | LBRACE declaration_list RBRACE
      {: RESULT = $1; :}
    | LBRACE declaration_list statement_list RBRACE
      {: RESULT = $1; :}
    ;

declaration_list ::=
      declaration
      {: RESULT = $1; :}
    | declaration_list declaration
      {: RESULT = $1; :}
    ;

statement_list ::=
      statement
      {: RESULT = $1; :}
    | statement_list statement
      {: RESULT = $1; :}
    ;

/* Expression and null statements */
expression_statement ::=
      SEMICOLON
      {: RESULT = $1; :}
    | expression SEMICOLON
      {: RESULT = $1; :}
    ;

/* Selection statements */
selection_statement ::=
      IF LPAREN expression RPAREN statement
      {: RESULT = $1; :}
    | IF LPAREN expression RPAREN statement ELSE statement
      {: RESULT = $1; :}
    ;

/* switch statement not implemented per requirements on moodle project guidnlines */

/* Iteration statements */
iteration_statement ::=
      WHILE LPAREN expression RPAREN statement
      {: RESULT = $1; :}
    | DO statement WHILE LPAREN expression RPAREN SEMICOLON
      {: RESULT = $1; :}
    | FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
      {: RESULT = $1; :}
    ;

expression_opt ::=
      /* empty */
      {: RESULT = null; :}
    | expression
      {: RESULT = $1; :}
    ;

/* Jump statements */
jump_statement ::=
      GOTO ID SEMICOLON
      {: RESULT = $1; :}
    | CONTINUE SEMICOLON
      {: RESULT = $1; :}
    | BREAK SEMICOLON
      {: RESULT = $1; :}
    | RETURN SEMICOLON
      {: RESULT = $1; :}
    | RETURN expression SEMICOLON
      {: RESULT = $1; :}
    ;